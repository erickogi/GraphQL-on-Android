{"version":3,"sources":["../src/cli.js"],"names":["on","error","handleError","exit","command","output","demand","describe","default","normalize","coerce","resolve","header","alias","type","arg","additionalHeaders","split","name","value","argv","outputPath","server","schema","target","choices","inputPaths","input","map","options","passthroughCustomScalars","fail","message","help","version","strict"],"mappings":";;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AAEA;;AACA;;AAEA;;;;AAEA;AACA,kBAAQA,EAAR,CAAW,oBAAX,EAAkCC,KAAD,IAAW;AAAE,QAAMA,KAAN;AAAa,CAA3D;;AAEA,kBAAQD,EAAR,CAAW,mBAAX,EAAgCE,WAAhC;;AAEA,SAASA,WAAT,CAAqBD,KAArB,EAA4B;AAC1B,wBAASA,KAAT;AACA,oBAAQE,IAAR,CAAa,CAAb;AACD;;AAED,gBACGC,OADH,CAEI,0BAFJ,EAGI,yCAHJ,EAII;AACEC,UAAQ;AACNC,YAAQ,IADF;AAENC,cAAU,qCAFJ;AAGNC,aAAS,aAHH;AAINC,eAAW,IAJL;AAKNC,YAAQ,eAAKC;AALP,GADV;AAQEC,UAAQ;AACNC,WAAO,GADD;AAENN,cAAU,oFAFJ;AAGNO,UAAM,OAHA;AAINJ,YAASK,GAAD,IAAS;AACf,UAAIC,oBAAoB,EAAxB;AACA,WAAK,MAAMJ,MAAX,IAAqBG,GAArB,EAA0B;AAAA,4BACFH,OAAOK,KAAP,CAAa,SAAb,CADE;AAAA;;AAAA,cACjBC,IADiB;AAAA,cACXC,KADW;;AAExB,YAAI,EAAED,QAAQC,KAAV,CAAJ,EAAsB;AACpB,gBAAM,sBAAc,8CAAd,CAAN;AACD;AACDH,0BAAkBE,IAAlB,IAA0BC,KAA1B;AACD;AACD,aAAOH,iBAAP;AACD;AAdK;AARV,CAJJ;AAAA,6CA6BI,WAAMI,IAAN,EAAc;AACZ,UAAMC,aAAa,eAAKV,OAAL,CAAaS,KAAKf,MAAlB,CAAnB;AACA,UAAMW,oBAAoBI,KAAKR,MAA/B;AACA,UAAM,sBAAeQ,KAAKE,MAApB,EAA4BD,UAA5B,EAAwCL,iBAAxC,CAAN;AACD,GAjCL;;AAAA;AAAA;AAAA;AAAA,MAmCGZ,OAnCH,CAoCI,qBApCJ,EAqCI,yDArCJ,EAsCI;AACEmB,UAAQ;AACNjB,YAAQ,IADF;AAENC,cAAU,6BAFJ;AAGNC,aAAS,aAHH;AAINC,eAAW,IAJL;AAKNC,YAAQ,eAAKC;AALP,GADV;AAQEN,UAAQ;AACNE,cAAU,0CADJ;AAENE,eAAW,IAFL;AAGNC,YAAQ,eAAKC;AAHP,GARV;AAaEa,UAAQ;AACNlB,YAAQ,KADF;AAENC,cAAU,iCAFJ;AAGNkB,aAAS,CAAC,OAAD,EAAU,MAAV,EAAkB,IAAlB,EAAwB,YAAxB,EAAsC,MAAtC,CAHH;AAINjB,aAAS;AAJH,GAbV;AAmBE,gCAA8B;AAC5BF,YAAQ,KADoB;AAE5BC,cAAU,wDAFkB;AAG5BC,aAAS;AAHmB;AAnBhC,CAtCJ,EA+DIY,QAAQ;AACN,QAAMM,aAAaN,KAAKO,KAAL,CAAWC,GAAX,CAAeD,SAAS,eAAKhB,OAAL,CAAagB,KAAb,CAAxB,CAAnB;AACA,QAAME,UAAU,EAAEC,0BAA0BV,KAAK,4BAAL,CAA5B,EAAhB;AACA,kBAASM,UAAT,EAAqBN,KAAKG,MAA1B,EAAkCH,KAAKf,MAAvC,EAA+Ce,KAAKI,MAApD,EAA4DK,OAA5D;AACD,CAnEL,EAqEGE,IArEH,CAqEQ,UAASC,OAAT,EAAkB/B,KAAlB,EAAyB;AAC7BC,cAAYD,QAAQA,KAAR,GAAgB,sBAAc+B,OAAd,CAA5B;AACD,CAvEH,EAwEGC,IAxEH,GAyEGC,OAzEH,GA0EGC,MA1EH,GA2EGf,IA3EH","file":"cli.js","sourcesContent":["\n\nimport process from 'process';\nimport path from 'path';\nimport yargs from 'yargs';\n\nimport { downloadSchema, generate } from '.';\nimport { ToolError, logError } from './errors'\n\nimport 'source-map-support/register'\n\n// Make sure unhandled errors in async code are propagated correctly\nprocess.on('unhandledRejection', (error) => { throw error });\n\nprocess.on('uncaughtException', handleError);\n\nfunction handleError(error) {\n  logError(error);\n  process.exit(1);\n}\n\nyargs\n  .command(\n    'download-schema <server>',\n    'Download a GraphQL schema from a server',\n    {\n      output: {\n        demand: true,\n        describe: 'Output path for GraphQL schema file',\n        default: 'schema.json',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      header: {\n        alias: 'H',\n        describe: 'Additional header to send to the server as part of the introspection query request',\n        type: 'array',\n        coerce: (arg) => {\n          let additionalHeaders = {};\n          for (const header of arg) {\n            const [name, value] = header.split(/\\s*:\\s*/);\n            if (!(name && value)) {\n              throw new ToolError('Headers should be specified as \"Name: Value\"');\n            }\n            additionalHeaders[name] = value;\n          }\n          return additionalHeaders;\n        }\n      },\n    },\n    async argv => {\n      const outputPath = path.resolve(argv.output);\n      const additionalHeaders = argv.header;\n      await downloadSchema(argv.server, outputPath, additionalHeaders);\n    }\n  )\n  .command(\n    'generate [input...]',\n    'Generate code from a GraphQL schema and query documents',\n    {\n      schema: {\n        demand: true,\n        describe: 'Path to GraphQL schema file',\n        default: 'schema.json',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      output: {\n        describe: 'Output directory for the generated files',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      target: {\n        demand: false,\n        describe: 'Code generation target language',\n        choices: ['swift', 'json', 'ts', 'typescript', 'flow'],\n        default: 'swift'\n      },\n      \"passthrough-custom-scalars\": {\n        demand: false,\n        describe: \"Don't attempt to map custom scalars [temporary option]\",\n        default: false\n      }\n    },\n    argv => {\n      const inputPaths = argv.input.map(input => path.resolve(input));\n      const options = { passthroughCustomScalars: argv[\"passthrough-custom-scalars\"] };\n      generate(inputPaths, argv.schema, argv.output, argv.target, options);\n    },\n  )\n  .fail(function(message, error) {\n    handleError(error ? error : new ToolError(message));\n  })\n  .help()\n  .version()\n  .strict()\n  .argv\n"]}