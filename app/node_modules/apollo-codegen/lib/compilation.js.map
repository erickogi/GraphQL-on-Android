{"version":3,"sources":["../src/compilation.js"],"names":["compileToIR","printIR","builtInScalarTypes","isBuiltInScalarType","type","has","schema","document","compiler","Compiler","operations","forEach","operation","name","value","compileOperation","fragments","fragment","compileFragment","typesUsed","constructor","typesUsedSet","fragmentMap","definition","definitions","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","compiledFragmentMap","addTypeUsed","add","field","getFields","fragmentNamed","fragmentName","operationDefinition","filePath","operationName","operationType","variables","variableDefinitions","map","node","variable","source","withTypenameFieldAddedWhereNeeded","rootType","groupedVisitedFragmentSet","groupedFieldSet","collectFields","selectionSet","undefined","fragmentsReferencedSet","resolveFields","fields","fragmentsReferenced","fragmentDefinition","typeCondition","fragmentSpreads","inlineFragments","parentType","Error","String","selection","selections","FIELD","fieldName","responseName","alias","args","argumentsFromAST","arguments","directives","INLINE_FRAGMENT","inlineFragmentType","effectiveType","FRAGMENT_SPREAD","fragmentType","visitedFragmentSet","get","set","mergeSelectionSets","fieldSet","filter","length","firstField","isConditional","some","directive","directiveName","bareType","subSelectionGroupedVisitedFragmentSet","subSelectionGroupedFieldSet","fragmentSpreadsForParentType","resolveInlineFragments","values","fragmentsReferencedFromFragment","fragmentReferenced","collectPossibleTypes","possibleTypes","isPossibleType","keys","typenameField","NAME","ast","typeInfo","leave","SelectionSet","getParentType","sourceAt","location","body","slice","start","end","arg","variableName","concat","inlineFragment"],"mappings":"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","file":"compilation.js","sourcesContent":["import {\n  print,\n  visit,\n  visitWithTypeInfo,\n  typeFromAST,\n  getNamedType,\n  isAbstractType,\n  isEqualType,\n  isTypeSubTypeOf,\n  Kind,\n  TypeInfo,\n  isType,\n  isCompositeType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLError\n} from 'graphql';\n\nimport {\n  isTypeProperSuperTypeOf,\n  getOperationRootType,\n  getFieldDef,\n  valueFromValueNode,\n  filePathForNode\n} from './utilities/graphql';\n\nimport {\n  join,\n  block,\n  wrap,\n  indent\n} from './utilities/printing';\n\nconst builtInScalarTypes = new Set([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);\n\nfunction isBuiltInScalarType(type) {\n  return builtInScalarTypes.has(type);\n}\n\n// Parts of this code are adapted from graphql-js\n\nexport function compileToIR(schema, document) {\n  const compiler = new Compiler(schema, document);\n\n  const operations = Object.create(null);\n\n  compiler.operations.forEach(operation => {\n    operations[operation.name.value] = compiler.compileOperation(operation)\n  });\n\n  const fragments = Object.create(null);\n\n  compiler.fragments.forEach(fragment => {\n    fragments[fragment.name.value] = compiler.compileFragment(fragment)\n  });\n\n  const typesUsed = compiler.typesUsed;\n\n  return { schema, operations, fragments, typesUsed };\n}\n\nexport class Compiler {\n  constructor(schema, document) {\n    this.schema = schema;\n\n    this.typesUsedSet = new Set();\n\n    this.fragmentMap = Object.create(null);\n    this.operations = [];\n\n    for (const definition of document.definitions) {\n      switch (definition.kind) {\n        case Kind.OPERATION_DEFINITION:\n          this.operations.push(definition);\n          break;\n        case Kind.FRAGMENT_DEFINITION:\n          this.fragmentMap[definition.name.value] = definition;\n          break;\n      }\n    }\n\n    this.compiledFragmentMap = Object.create(null);\n  }\n\n  addTypeUsed(type) {\n    if (type instanceof GraphQLEnumType ||\n        type instanceof GraphQLInputObjectType ||\n        (type instanceof GraphQLScalarType && !isBuiltInScalarType(type))) {\n      this.typesUsedSet.add(type);\n    }\n    if (type instanceof GraphQLInputObjectType) {\n      for (const field of Object.values(type.getFields())) {\n        this.addTypeUsed(getNamedType(field.type));\n      }\n    }\n  }\n\n  get typesUsed() {\n    return Array.from(this.typesUsedSet);\n  }\n\n  fragmentNamed(fragmentName) {\n    return this.fragmentMap[fragmentName];\n  }\n\n  get fragments() {\n    return Object.values(this.fragmentMap);\n  }\n\n  compileOperation(operationDefinition) {\n    const filePath = filePathForNode(operationDefinition);\n    const operationName = operationDefinition.name.value;\n    const operationType = operationDefinition.operation;\n\n    const variables = operationDefinition.variableDefinitions.map(node => {\n      const name = node.variable.name.value;\n      const type = typeFromAST(this.schema, node.type);\n      this.addTypeUsed(getNamedType(type));\n      return { name, type };\n    });\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, operationDefinition));\n\n    const rootType = getOperationRootType(this.schema, operationDefinition);\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(rootType, operationDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields } = this.resolveFields(rootType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { filePath, operationName, operationType, variables, source, fields, fragmentsReferenced };\n  }\n\n  compileFragment(fragmentDefinition) {\n    const filePath = filePathForNode(fragmentDefinition);\n    const fragmentName = fragmentDefinition.name.value;\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, fragmentDefinition));\n\n    const typeCondition = typeFromAST(this.schema, fragmentDefinition.typeCondition);\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(typeCondition, fragmentDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(typeCondition, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { filePath, fragmentName, source, typeCondition, fields, fragmentSpreads, inlineFragments, fragmentsReferenced };\n  }\n\n  collectFields(parentType, selectionSet, groupedFieldSet = Object.create(null), groupedVisitedFragmentSet = new Map()) {\n    if (!isCompositeType(parentType)) {\n      throw new Error(`parentType should be a composite type, but is \"${String(parentType)}\"`);\n    }\n\n    for (const selection of selectionSet.selections) {\n      switch (selection.kind) {\n        case Kind.FIELD: {\n          const fieldName = selection.name.value;\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n\n          const field = getFieldDef(this.schema, parentType, selection);\n          if (!field) {\n            throw new GraphQLError(`Cannot query field \"${fieldName}\" on type \"${String(parentType)}\"`, [selection]);\n          }\n\n          if (groupedFieldSet) {\n            if (!groupedFieldSet[responseName]) {\n              groupedFieldSet[responseName] = [];\n            }\n\n            groupedFieldSet[responseName].push([parentType, {\n              responseName,\n              fieldName,\n              args: argumentsFromAST(selection.arguments),\n              type: field.type,\n              directives: selection.directives,\n              selectionSet: selection.selectionSet\n            }]);\n          }\n          break;\n        }\n        case Kind.INLINE_FRAGMENT: {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ?\n            typeFromAST(this.schema, typeCondition) :\n            parentType;\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : inlineFragmentType;\n\n          this.collectFields(\n            effectiveType,\n            selection.selectionSet,\n            groupedFieldSet,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n        case Kind.FRAGMENT_SPREAD: {\n          const fragmentName = selection.name.value;\n\n          const fragment = this.fragmentNamed(fragmentName);\n          if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n\n          const typeCondition = fragment.typeCondition;\n          const fragmentType = typeFromAST(this.schema, typeCondition)\n\n          if (groupedVisitedFragmentSet) {\n            let visitedFragmentSet = groupedVisitedFragmentSet.get(parentType);\n            if (!visitedFragmentSet) {\n              visitedFragmentSet = {};\n              groupedVisitedFragmentSet.set(parentType, visitedFragmentSet);\n            }\n\n            if (visitedFragmentSet[fragmentName]) continue;\n            visitedFragmentSet[fragmentName] = true;\n          }\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : fragmentType;\n\n          this.collectFields(\n            effectiveType,\n            fragment.selectionSet,\n            null,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  mergeSelectionSets(parentType, fieldSet, groupedVisitedFragmentSet) {\n    const groupedFieldSet = Object.create(null);\n\n    for (const [,field] of fieldSet) {\n      const selectionSet = field.selectionSet;\n\n      if (selectionSet) {\n        this.collectFields(parentType, selectionSet, groupedFieldSet, groupedVisitedFragmentSet);\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  resolveFields(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    const fields = [];\n\n    for (let [responseName, fieldSet] of Object.entries(groupedFieldSet)) {\n      fieldSet = fieldSet.filter(([typeCondition,]) => isTypeSubTypeOf(this.schema, parentType, typeCondition));\n      if (fieldSet.length < 1) continue;\n\n      const [,firstField] = fieldSet[0];\n      const fieldName = firstField.fieldName;\n      const args = firstField.args;\n      const type = firstField.type;\n\n      let field = { responseName, fieldName, type };\n\n      if (args && args.length > 0) {\n        field.args = args;\n      }\n\n      const isConditional = fieldSet.some(([,field]) => {\n        return field.directives && field.directives.some(directive => {\n          const directiveName = directive.name.value;\n          return directiveName == 'skip' || directiveName == 'include';\n        });\n      });\n\n      if (isConditional) {\n        field.isConditional = true;\n      }\n\n      const bareType = getNamedType(type);\n\n      this.addTypeUsed(bareType);\n\n      if (isCompositeType(bareType)) {\n        const subSelectionGroupedVisitedFragmentSet = new Map();\n        const subSelectionGroupedFieldSet = this.mergeSelectionSets(\n          bareType,\n          fieldSet,\n          subSelectionGroupedVisitedFragmentSet\n        );\n\n        const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(\n          bareType,\n          subSelectionGroupedFieldSet,\n          subSelectionGroupedVisitedFragmentSet,\n          fragmentsReferencedSet\n        );\n        Object.assign(field, { fields, fragmentSpreads, inlineFragments });\n      }\n\n      fields.push(field);\n    }\n\n    const fragmentSpreads = this.fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet);\n    const inlineFragments = this.resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n\n    if (fragmentsReferencedSet) {\n      Object.assign(fragmentsReferencedSet, ...groupedVisitedFragmentSet.values());\n\n      // TODO: This is a really inefficient way of keeping track of fragments referenced by other fragments\n      // We need to either cache compiled fragments or find a way to make resolveFields smarter\n      for (let fragmentName of fragmentSpreads) {\n        const fragment = this.fragmentNamed(fragmentName);\n        if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n        const { fragmentsReferenced: fragmentsReferencedFromFragment } = this.compileFragment(fragment);\n        for (let fragmentReferenced of fragmentsReferencedFromFragment) {\n          fragmentsReferencedSet[fragmentReferenced] = true;\n        }\n      }\n    }\n\n    return { fields, fragmentSpreads, inlineFragments };\n  }\n\n  resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    return this.collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet).map(typeCondition => {\n      const { fields, fragmentSpreads } = this.resolveFields(\n        typeCondition,\n        groupedFieldSet,\n        groupedVisitedFragmentSet,\n        fragmentsReferencedSet\n      );\n      return { typeCondition, fields, fragmentSpreads };\n    });\n  }\n\n  collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet) {\n    if (!isAbstractType(parentType)) return [];\n\n    const possibleTypes = new Set();\n\n    for (const fieldSet of Object.values(groupedFieldSet)) {\n      for (const [typeCondition,] of fieldSet) {\n        if (this.schema.isPossibleType(parentType, typeCondition)) {\n          possibleTypes.add(typeCondition);\n        }\n      }\n    }\n\n    // Also include type conditions for fragment spreads\n    if (groupedVisitedFragmentSet) {\n      for (const effectiveType of groupedVisitedFragmentSet.keys()) {\n        if (this.schema.isPossibleType(parentType, effectiveType)) {\n          possibleTypes.add(effectiveType);\n        }\n      }\n    }\n\n    return Array.from(possibleTypes);\n  }\n\n  fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet) {\n    if (!groupedVisitedFragmentSet) return [];\n\n    let fragmentSpreads = new Set();\n\n    for (const [effectiveType, visitedFragmentSet] of groupedVisitedFragmentSet) {\n      if (!isTypeProperSuperTypeOf(this.schema, effectiveType, parentType)) continue;\n\n      for (const fragmentName of Object.keys(visitedFragmentSet)) {\n        fragmentSpreads.add(fragmentName);\n      }\n    }\n\n    return Array.from(fragmentSpreads);\n  }\n}\n\nconst typenameField = { kind: Kind.FIELD, name: { kind: Kind.NAME, value: '__typename' } };\n\nfunction withTypenameFieldAddedWhereNeeded(schema, ast) {\n  const typeInfo = new TypeInfo(schema);\n\n  return visit(ast, visitWithTypeInfo(typeInfo, {\n    leave: {\n      SelectionSet: node => {\n        const parentType = typeInfo.getParentType();\n\n        if (isAbstractType(parentType)) {\n          return { ...node, selections: [typenameField, ...node.selections] };\n        }\n      }\n    }\n  }));\n}\n\nfunction sourceAt(location) {\n  return location.source.body.slice(location.start, location.end);\n}\n\nfunction argumentsFromAST(args) {\n  return args.map(arg => {\n    const kind = arg.value.kind;\n    if (kind === 'Variable') {\n      return {\n        kind,\n        name: arg.name.value,\n        variableName: arg.value.name.value\n      };\n    } else {\n      return {\n        name: arg.name.value,\n        value: valueFromValueNode(arg.value)\n      };\n    }\n  });\n}\n\nexport function printIR({ fields, inlineFragments, fragmentSpreads }) {\n  return fields && wrap('<', join(fragmentSpreads, ', '), '> ')\n    + block(fields.map(field =>\n      `${field.name}: ${String(field.type)}` + wrap(' ', printIR(field))\n    ).concat(inlineFragments && inlineFragments.map(inlineFragment =>\n      `${String(inlineFragment.typeCondition)}` + wrap(' ', printIR(inlineFragment)))));\n}\n"]}